% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sgccaNa.R
\name{sgccaNa}
\alias{sgccaNa}
\title{Regularized Generalized Canonical Correlation Analysis (RGCCA)}
\usage{
sgccaNa(
  blocks,
  method,
  connection = 1 - diag(length(blocks)),
  sparsity = rep(1, length(blocks)),
  ncomp = rep(1, length(blocks)),
  scheme = "centroid",
  scale = TRUE,
  init = "svd",
  bias = TRUE,
  tol = 1e-08,
  verbose = TRUE,
  scale_block = TRUE,
  prescaling = FALSE,
  quiet = FALSE
)
}
\arguments{
\item{blocks}{A list of blocks}

\item{method}{Either a character corresponding to the used method
("complete","knn","em","sem") or a function taking a list of J blocks (A) as
only parameter and returning the imputed list.
\itemize{
\item{\code{"mean"}}{ corresponds to an imputation by the colmeans}
\item{\code{"complete"}}{ corresponds to run RGCCA only on the complete
subjects (subjects with missing data are removed)}
\item{\code{"nipals"}}{ corresponds to run RGCCA on all available data
(NIPALS algorithm)}
\item{\code{"em"}}{ corresponds to impute the data with EM-type algorithms}
\item{\code{"sem"}}{ corresponds to impute the data with EM-type algorithms
with superblock approach}
\item{\code{"knn1"}}{ corresponds to impute the data with the 1-Nearest
Neighbor. 1 can be replace by another number (such as knn3) to impute with
the 3-Nearest Neighbors.}}}

\item{connection}{A symmetric matrix (J*J) that describes the relationships
between blocks. Elements of the connection matrix must be positive ; but
usually equal to 1 if block \eqn{j} and block \eqn{k} are connected, and 0
otherwise.}

\item{sparsity}{Either a \eqn{1*J} vector or a \eqn{max(ncomp) * J} matrix 
encoding the L1 constraints applied to the outer weight vectors. The amount 
of sparsity varies between \eqn{1/sqrt(p_j)} and 1 (larger values of sparsity 
correspond to less penalization). If sparsity is a vector, L1-penalties are 
the same for all the weights corresponding to the same block but different 
components: 
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[j] \sqrt{p_j},}
with \eqn{p_j} the number of variables of \eqn{X_j}.
If sparsity is a matrix, each row \eqn{h} defines the constraints applied to 
the weights corresponding to components \eqn{h}:
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[h,j] \sqrt{p_j}.} It can be 
estimated by using \link{rgcca_permutation}.}

\item{ncomp}{A vector of length J indicating the number of block components
for each block.}

\item{scheme}{A character string or a function giving the scheme function for
covariance maximization among "horst" (the identity function), "factorial"
 (the squared values), "centroid" (the absolute values). The scheme function
 can be any continously differentiable convex functin and it is possible to
 design explicitely the sheme function (e.g. function(x) x^4) as argument of
 rgcca function.  See (Tenenhaus et al, 2017) for details.}

\item{scale}{A logical value indicating if each block is standardized}

\item{init}{A character giving the mode of initialization to use in the
algorithm. The alternatives are either by Singular Value Decompostion ("svd")
or random ("random") (default: "svd").}

\item{bias}{A logical value for biaised (\eqn{1/n}) or unbiaised
(\eqn{1/(n-1)}) estimator of the var/cov (default: bias = TRUE).}

\item{tol}{The stopping value for the convergence of the algorithm.}

\item{verbose}{A logical value indicating whether the warnings are displayed}

\item{scale_block}{A logical value indicating if each block is divided by
the square root of its number of variables.}

\item{prescaling}{A logical value indicating if the scaling has been done
outside of the function.}

\item{quiet}{A boolean hidding the warnings}
}
\value{
\item{Y}{A list of \eqn{J} elements. Each element of \eqn{Y} is a
matrix that contains the analysis components for the corresponding block.}

\item{a}{A list of \eqn{J} elements. Each element of \eqn{a} is a
matrix that contains the outer weight vectors for each block.}

\item{astar}{A list of \eqn{J} elements. Each element of astar is a
matrix defined as Y[[j]][, h] = A[[j]]\%*\%astar[[j]][, h].}

\item{C}{A symmetric matrix (J*J) that describes the relationships
between blocks}

\item{scheme}{A character or a function giving the link function for
covariance maximization among "horst" (the identity function), "factorial"
 (the squared values), "centroid" (the absolute values). Only, the horst
 scheme penalizes structural negative correlation. The factorial scheme
 discriminates more strongly the blocks than the centroid one}

\item{ncomp}{A vector of 1*J integers giving the number of component
for each blocks}

\item{crit}{A vector of integer that contains for each component the
values of the analysis criteria across iterations.}

\item{mode}{A \eqn{1 \times J} vector that contains the formulation
("primal" or "dual") applied to each of the \eqn{J} blocks within the RGCCA
alogrithm}

\item{AVE}{A list of numerical values giving the indicators of model
quality based on the Average Variance Explained (AVE): AVE(for each block),
AVE(outer model), AVE(inner model).}
}
\description{
imputeRGCCA allows to choose the imputation method before running RGCCA
}
\examples{
data(Russett)
X_agric <- as.matrix(Russett[, c("gini", "farm", "rent")])
X_ind <- as.matrix(Russett[, c("gnpr", "labo")])
X_polit <- as.matrix(Russett[, c("demostab", "dictator")])
X_agric[c(2, 4), ] <- NA # blockwise missing structure
X_ind[1, ] <- NA # Ponctual NA
X_polit[5, 1] <- NA
A <- list(Agric = X_agric, Ind = X_ind, Polit = X_polit)
rgccaNa(A, method = "nipals")

}
\references{
Tenenhaus A. and Tenenhaus M., (2011), Regularized Generalized
Canonical Correlation Analysis, Psychometrika, Vol. 76, Nr 2, pp 257-284.

Tenenhaus A., Philippe C., and Frouin V. (2015). Kernel
Generalized Canonical Correlation Analysis. Computational Statistics and
Data Analysis, 90, 114-131.

Schafer J. and Strimmer K., (2005), A shrinkage approach to
large-scale covariance matrix estimation and implications for functional
genomics. Statistical Applications in Genetics and Molecular Biology 4:32.
}
