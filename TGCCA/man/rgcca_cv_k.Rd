% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rgcca_cv_k.R
\name{rgcca_cv_k}
\alias{rgcca_cv_k}
\title{Cross-validation}
\usage{
rgcca_cv_k(
  rgcca_res,
  validation = "kfold",
  model = "regression",
  fit = "lm",
  new_scaled = TRUE,
  k = 5,
  scale = NULL,
  scale_block = NULL,
  tol = 1e-08,
  scheme = NULL,
  method = NULL,
  type = NULL,
  init = NULL,
  bias = NULL,
  connection = NULL,
  ncomp = NULL,
  tau = NULL,
  sparsity = NULL,
  n_cores = parallel::detectCores() - 1,
  parallelization = TRUE,
  ...
)
}
\arguments{
\item{rgcca_res}{A fitted RGCCA object (see  \code{\link[RGCCA]{rgcca}})}

\item{validation}{A character for the type of validation among "loo", "kfold", "test".}

\item{model}{A character corresponding to the model of prediction among : regression or classification}

\item{fit}{A character giving the function used to compare the trained and the tested models}

\item{new_scaled}{A boolean scaling the blocks to predict}

\item{k}{An integer giving the number of folds (if validation = 'kfold').}

\item{scale}{A logical value indicating if each block is standardized}

\item{scale_block}{A logical value indicating if each block is divided by
the square root of its number of variables.}

\item{tol}{The stopping value for the convergence of the algorithm.}

\item{scheme}{A character string or a function giving the scheme function for
covariance maximization among "horst" (the identity function), "factorial"
 (the squared values), "centroid" (the absolute values). The scheme function
 can be any continously differentiable convex functin and it is possible to
 design explicitely the sheme function (e.g. function(x) x^4) as argument of
 rgcca function.  See (Tenenhaus et al, 2017) for details.}

\item{method}{Either a character corresponding to the used method
("complete","knn","em","sem") or a function taking a list of J blocks (A) as
only parameter and returning the imputed list.
\itemize{
\item{\code{"mean"}}{ corresponds to an imputation by the colmeans}
\item{\code{"complete"}}{ corresponds to run RGCCA only on the complete
subjects (subjects with missing data are removed)}
\item{\code{"nipals"}}{ corresponds to run RGCCA on all available data
(NIPALS algorithm)}
\item{\code{"em"}}{ corresponds to impute the data with EM-type algorithms}
\item{\code{"sem"}}{ corresponds to impute the data with EM-type algorithms
with superblock approach}
\item{\code{"knn1"}}{ corresponds to impute the data with the 1-Nearest
Neighbor. 1 can be replace by another number (such as knn3) to impute with
the 3-Nearest Neighbors.}}}

\item{type}{A character string indicating the multi-block component
method to consider: rgcca, sgcca, pca, spca, pls, spls, cca,
ifa, ra, gcca, maxvar, maxvar-b, maxvar-a, mcoa,cpca-1, cpca-2,
cpca-4, hpca, maxbet-b, maxbet, maxdiff-b, maxdiff, maxvar-a,
sabscor, ssqcor, ssqcor, ssqcov-1, ssqcov-2, ssqcov, sumcor,
sumcov-1, sumcov-2, sumcov, sabscov, sabscov-1, sabscov-2.}

\item{init}{A character giving the mode of initialization to use in the
algorithm. The alternatives are either by Singular Value Decompostion ("svd")
or random ("random") (default: "svd").}

\item{bias}{A logical value for biaised (\eqn{1/n}) or unbiaised
(\eqn{1/(n-1)}) estimator of the var/cov (default: bias = TRUE).}

\item{connection}{A symmetric matrix (J*J) that describes the relationships
between blocks. Elements of the connection matrix must be positive ; but
usually equal to 1 if block \eqn{j} and block \eqn{k} are connected, and 0
otherwise.}

\item{ncomp}{A vector of length J indicating the number of block components
for each block.}

\item{tau}{Either a 1*J vector or a \eqn{\mathrm{max}(ncomp) \times J} matrix
containing the values of the regularization parameters (default: tau = 1,
for each block and each dimension). Tau varies from 0 (maximizing the
correlation) to 1 (maximizing the covariance). If tau = "optimal" the
regularization paramaters are estimated for each block and each dimension
using the Schafer and Strimmer (2005) analytical formula . If tau is a
\eqn{1\times J} vector, tau[j] is identical across the dimensions of block
\eqn{\mathbf{X}_j}. If tau is a matrix, tau[k, j] is associated with
\eqn{\mathbf{X}_{jk}} (\eqn{k}th residual matrix for block \eqn{j}). It can
be estimated by using \link{rgcca_permutation}.}

\item{sparsity}{Either a \eqn{1*J} vector or a \eqn{max(ncomp) * J} matrix 
encoding the L1 constraints applied to the outer weight vectors. The amount 
of sparsity varies between \eqn{1/sqrt(p_j)} and 1 (larger values of sparsity 
correspond to less penalization). If sparsity is a vector, L1-penalties are 
the same for all the weights corresponding to the same block but different 
components: 
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[j] \sqrt{p_j},}
with \eqn{p_j} the number of variables of \eqn{X_j}.
If sparsity is a matrix, each row \eqn{h} defines the constraints applied to 
the weights corresponding to components \eqn{h}:
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[h,j] \sqrt{p_j}.} It can be 
estimated by using \link{rgcca_permutation}.}

\item{n_cores}{Number of cores for parallelization}

\item{parallelization}{logical value. If TRUE (default value), the
permutation procedure is parallelized}

\item{...}{Further graphical parameters (see plot2D functions)}
}
\description{
Uses cross-validation to evaluate predictive model of RGCCA
}
\examples{
data("Russett")
blocks <- list(
  agriculture = Russett[, seq(3)], industry = Russett[, 4:5],
  politic = Russett[, 6:11]
)
rgcca_out <- rgcca(blocks, response = 3, superblock = FALSE)
res <- rgcca_cv_k(rgcca_out, validation = "kfold", k = 5, n_cores = 1)
rgcca_cv_k(rgcca_out, n_cores = 1)
}
\seealso{
\link{rgcca}, \link{rgcca_predict}, \link{plot.predict}
}
